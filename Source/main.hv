
PointType := class
{
	pos := vec2f
	velocity := vec2f
}

TWindow := class extends Window
{
	MousePos := vec2f
	
	MouseMoved := virtual !(double x, double y) -> void
	{
		MousePos.x = x
		MousePos.y = y
	}
}

PushC := class
{
	nowPos := vec2f
	deltaTime := float
	doAdd := bool
}

main := !(char^[] args) -> int
{
	x := 800
	y := 800

	win := new TWindow
	win.Init(x,y,"Pixels",true)
	
	VulkanInit(win)

	vInstance := vk

	vk.CreateSwapchain(x,y)

	shadersDB := VulkanShaderLoader

	cacheFile := new CacheFile("EngineData.zip")
	shadersDB.SetCacheFile(cacheFile)

	renderPass := vk.CreateRenderPass(![
			TRenderPassFrame(vk.SwapImageFormat, VK_IMAGE_LAYOUT_UNDEFINED,VK_IMAGE_LAYOUT_PRESENT_SRC_KHR)
		],false)

	ctx := GameContext

	ctx.pointsCount = 1024*32

	vk.initCreateStageMemory()

	ctx.vertData = vk.CreateMemBuffer(ctx.pointsCount*PointType->TypeSize,"vsr")


	{
		verts := Vector.{PointType}
		verts.Resize(ctx.pointsCount)

		for it : verts
		{
			it.pos.x = RandInt(0..1000) / 1000 - 0.5
			it.pos.y = RandInt(0..1000) / 1000 - 0.5
			it.pos *= vec2f(2.0,2.0)
		}
		ctx.vertData.TransferData(verts)
	}

	layout := renderPass.CreateLayout(PointType,resultImageCount = 1)


	shadersDB.SetInput("light",layout)

	ctx.mainShader = shadersDB.LoadShader("Shaders/test.json")


	zeroPass := vk.CreateRenderPass(![],false)
	computeLayout := zeroPass.CreateLayout(sets = ![new TComputeStorage()],pushConstants = ![ new TComputePushConstant(PushC->TypeSize)])

	compShader := shadersDB.LoadComputeShader(vk,computeLayout,"Shaders/bap.comp")

	pool := computeLayout.CreateDescriptorPool(0,1)
	desc := pool.CreateDescriptor()

	f2 := VkDescriptorBufferInfo
	f2.buffer = ctx.vertData.itBuffer
	f2.range = ctx.pointsCount * PointType->TypeSize

	setD := VkWriteDescriptorSet()
	setD.dstSet = desc
	setD.descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER
	setD.descriptorCount = 1
	setD.pBufferInfo&->{void^^}^ = f2&

	vk.Funcs.vkUpdateDescriptorSets(vk.LogicalDevice,1,setD&,0,null)
	
	cmds := TVkCommandBuffer(vk,vk.itDrawCmdPool2)

	oldTime := GetSteadyTime()

	while not win.ShouldClose()
	{

		surfaceIndex := u32
		drawRes := false
		@work vk.DrawGetImage(surfaceIndex&,drawRes&)

		thisTime := GetSteadyTime()
		deltaTime := thisTime - oldTime
		oldTime = thisTime

		cmds.Reset()
		cmds.Start()

		{
			pc := PushC
			pc.nowPos = win.MousePos
			pc.nowPos.x = pc.nowPos.x / x
			pc.nowPos.y  = pc.nowPos.y/ y
			pc.deltaTime = deltaTime
			pc.doAdd = buttons['q']

			vk.Funcs.vkCmdBindPipeline(cmds.Get(),VK_PIPELINE_BIND_POINT_COMPUTE,compShader.itPipe)
			vk.Funcs.vkCmdPushConstants(cmds.Get(),compShader.itLayout,VK_SHADER_STAGE_COMPUTE_BIT,0,PushC->TypeSize,pc&)
			vk.Funcs.vkCmdBindDescriptorSets(cmds.Get(), VK_PIPELINE_BIND_POINT_COMPUTE, computeLayout.itLayout , 0, 1, desc&, 0, null);
			vk.Funcs.vkCmdDispatch(cmds.Get(),ctx.pointsCount,1,1)
		}

		DrawParticles(ctx,cmds,surfaceIndex,x,y)

		cmds.Stop()
		cmds.Submit(vk.DrawQueue,null)
		vk.Funcs.vkQueueWaitIdle(vk.DrawQueue)

		vk.DrawPresentImage(surfaceIndex)

		win.PollEvents()
	}
	return 0
}
