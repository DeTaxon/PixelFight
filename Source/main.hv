
PointType := class
{
	pos := vec2f
	velocity := vec2f

	"=" := default
}

TWindow := class extends Window
{
	MousePos := vec2f
	
	MouseMoved := virtual !(double x, double y) -> void
	{
		MousePos.x = x
		MousePos.y = y
	}
}

PushCMouseMove := class
{
	nowPos := vec2f
	deltaTime := float
}
PushCMove := class
{
	deltaTime := float
}

main := !(char^[] args) -> int
{
	x := 800
	y := 800

	win := new TWindow
	win.Init(x,y,"Pixels",true)

	VulkanInit(win)

	vInstance := vk

	vk.CreateSwapchain(x,y)

	shadersDB := VulkanShaderLoader

	renderPass := vk.CreateRenderPass(![
			TRenderPassFrame(vk.SwapImageFormat, VK_IMAGE_LAYOUT_UNDEFINED,VK_IMAGE_LAYOUT_PRESENT_SRC_KHR)
		],false)

	ctx := GameContext

	ctx.pointsCount = 1024*32

	vk.initCreateStageMemory()

	ctx.vertData = vk.CreateMemBuffer(ctx.pointsCount*PointType->TypeSize,"vsr")


	{
		verts := Vector.{PointType}
		verts.Resize(ctx.pointsCount)

		for it : verts
		{
			it.pos.x = RandInt(0..1000) / 1000 - 0.5
			it.pos.y = RandInt(0..1000) / 1000 - 0.5
			it.pos *= vec2f(2.0,2.0)
		}
		ctx.vertData.TransferData(verts)
	}


	layout := renderPass.CreateLayout(PointType,![],![],resultImageCount = 1,topology = "Points")

	shadersDB.SetInput("light",layout)

	ctx.mainShader = shadersDB.LoadShader("ShadersBin/test.json")

	zeroPass := vk.CreateRenderPass(![],false)
	tmp := TShaderInputVertexInfo

	baseLayout := zeroPass.CreateLayout(tmp,![new TComputeStorage()],![ new TComputePushConstant(128)])

	// mouseMoveLayout := zeroPass.CreateLayout(tmp,![new TComputeStorage()],![ new TComputePushConstant(PushCMouseMove->TypeSize)])
	mouseMoveShader := shadersDB.LoadComputeShader(vk,baseLayout,"ShadersBin/MouseMove.comp")

	// moveLayout := zeroPass.CreateLayout(tmp,![new TComputeStorage()],![ new TComputePushConstant(PushCMove->TypeSize)])
	moveShader := shadersDB.LoadComputeShader(vk,baseLayout,"ShadersBin/Move.comp")

	pool := baseLayout.CreateDescriptorPool(0,1)
	desc := pool.CreateDescriptor()

	f2 := VkDescriptorBufferInfo
	f2.buffer = ctx.vertData.itBuffer
	f2.range = ctx.pointsCount * PointType->TypeSize

	setD := VkWriteDescriptorSet()
	setD.dstSet = desc
	setD.descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER
	setD.descriptorCount = 1
	setD.pBufferInfo&->{void^^}^ = f2&

	vk.Funcs.vkUpdateDescriptorSets(vk.LogicalDevice,1,setD&,0,null)

	// if #DebugMode()
		shadersDB.SetFolderHotload("ShadersBin/")
	
	cmds := TVkCommandBuffer(vk,vk.itDrawCmdPool2)

	oldTime := GetSteadyTime()

	while not win.ShouldClose()
	{
		// if #DebugMode()
			shadersDB.UpdateShaders(vk)

		surfaceIndex := u32
		drawRes := false
		@work vk.DrawGetImage(surfaceIndex&,drawRes&)

		thisTime := GetSteadyTime()
		deltaTime := thisTime - oldTime
		oldTime = thisTime

		cmds.Reset()
		cmds.Start()

		if buttons['q']
		{
			pc := PushCMouseMove
			pc.nowPos = win.MousePos
			pc.nowPos.x = pc.nowPos.x / x
			pc.nowPos.y  = pc.nowPos.y/ y
			pc.deltaTime = deltaTime

			vk.Funcs.vkCmdBindPipeline(cmds.Get(),VK_PIPELINE_BIND_POINT_COMPUTE,mouseMoveShader.itPipe)
			vk.Funcs.vkCmdPushConstants(cmds.Get(),mouseMoveShader.itLayout,VK_SHADER_STAGE_COMPUTE_BIT,0,PushCMouseMove->TypeSize,pc&)
			vk.Funcs.vkCmdBindDescriptorSets(cmds.Get(), VK_PIPELINE_BIND_POINT_COMPUTE, baseLayout.itLayout , 0, 1, desc&, 0, null);
			vk.Funcs.vkCmdDispatch(cmds.Get(),ctx.pointsCount,1,1)
		}

		{
			pc := PushCMove
			pc.deltaTime = deltaTime

			vk.Funcs.vkCmdBindPipeline(cmds.Get(),VK_PIPELINE_BIND_POINT_COMPUTE,moveShader.itPipe)
			vk.Funcs.vkCmdPushConstants(cmds.Get(),moveShader.itLayout,VK_SHADER_STAGE_COMPUTE_BIT,0,PushCMove->TypeSize,pc&)
			vk.Funcs.vkCmdBindDescriptorSets(cmds.Get(), VK_PIPELINE_BIND_POINT_COMPUTE, baseLayout.itLayout , 0, 1, desc&, 0, null);
			vk.Funcs.vkCmdDispatch(cmds.Get(),ctx.pointsCount,1,1)
		}

		DrawParticles(ctx,cmds,surfaceIndex,x,y)

		cmds.Stop()
		cmds.Submit(vk.DrawQueue,null)
		vk.Funcs.vkQueueWaitIdle(vk.DrawQueue)

		vk.DrawPresentImage(surfaceIndex)

		win.PollEvents()
	}
	win.DestroyWindow()
	return 0
}
